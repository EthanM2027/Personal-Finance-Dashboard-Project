#!/usr/bin/env python3
"""
Password Security Analyzer & Manager - Starter Version
A foundational tool for password analysis, breach checking, and secure storage.

Required installations:
pip install cryptography requests

Note: If you get SSL/certificate errors, you may need:
pip install --upgrade certifi requests[security]
"""

import hashlib
import re
import json
import os
import getpass
import base64
import time
import sys

# Try importing required libraries with helpful error messages
try:
    import requests
except ImportError:
    print("‚ùå Error: 'requests' library not found.")
    print("Install with: pip install requests")
    sys.exit(1)

try:
    from cryptography.fernet import Fernet
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
except ImportError:
    print("‚ùå Error: 'cryptography' library not found.")
    print("Install with: pip install cryptography")
    print("If that fails, try: pip install --upgrade pip setuptools wheel")
    print("Then: pip install cryptography")
    sys.exit(1)

class PasswordAnalyzer:
    """Analyzes password strength and security."""
    
    def __init__(self):
        self.common_passwords = self._load_common_passwords()
    
    def _load_common_passwords(self):
        """Load common passwords for checking. In production, load from a file."""
        return {
            'password', '123456', '123456789', 'qwerty', 'abc123', 
            'password123', 'admin', 'letmein', 'welcome', '1234567890'
        }
    
    def analyze_strength(self, password):
        """Analyze password strength and return detailed results."""
        score = 0
        feedback = []
        
        # Length check
        if len(password) >= 12:
            score += 25
        elif len(password) >= 8:
            score += 15
            feedback.append("Consider using a longer password (12+ characters)")
        else:
            feedback.append("Password is too short (minimum 8 characters)")
        
        # Character variety checks
        if re.search(r'[a-z]', password):
            score += 10
        else:
            feedback.append("Add lowercase letters")
            
        if re.search(r'[A-Z]', password):
            score += 10
        else:
            feedback.append("Add uppercase letters")
            
        if re.search(r'\d', password):
            score += 10
        else:
            feedback.append("Add numbers")
            
        if re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
            score += 15
        else:
            feedback.append("Add special characters (!@#$%^&*)")
        
        # Pattern checks
        if not re.search(r'(.)\1{2,}', password):  # No 3+ repeated chars
            score += 10
        else:
            feedback.append("Avoid repeating characters")
            
        if not re.search(r'(012|123|234|345|456|567|678|789|890|abc|bcd|cde)', password.lower()):
            score += 10
        else:
            feedback.append("Avoid sequential characters")
        
        # Common password check
        if password.lower() not in self.common_passwords:
            score += 10
        else:
            feedback.append("This is a commonly used password")
            score = min(score, 20)  # Cap score for common passwords
        
        # Determine strength level
        if score >= 80:
            strength = "Very Strong"
        elif score >= 60:
            strength = "Strong"
        elif score >= 40:
            strength = "Moderate"
        elif score >= 20:
            strength = "Weak"
        else:
            strength = "Very Weak"
        
        return {
            'score': score,
            'strength': strength,
            'feedback': feedback,
            'length': len(password)
        }

class BreachChecker:
    """Checks passwords against breach databases using HaveIBeenPwned API."""
    
    def __init__(self):
        self.api_url = "https://api.pwnedpasswords.com/range/"
        self.request_delay = 1.5  # Rate limiting
    
    def check_password_breach(self, password):
        """Check if password appears in known data breaches."""
        try:
            # Hash the password using SHA-1
            sha1_hash = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()
            hash_prefix = sha1_hash[:5]
            hash_suffix = sha1_hash[5:]
            
            # Query HaveIBeenPwned API with first 5 chars of hash
            response = requests.get(
                f"{self.api_url}{hash_prefix}",
                timeout=10,
                headers={
                    'User-Agent': 'PasswordManager-Learning-Tool',
                    'Accept': 'text/plain'
                },
                verify=True  # Ensure SSL verification
            )
            response.raise_for_status()
            
            # Check if our hash suffix appears in the response
            for line in response.text.splitlines():
                if ':' in line:  # Safety check for line format
                    hash_part, count = line.split(':', 1)  # Split only on first colon
                    if hash_part == hash_suffix:
                        return {
                            'breached': True,
                            'count': int(count),
                            'message': f"Password found in {count} data breaches!"
                        }
            
            time.sleep(self.request_delay)  # Rate limiting
            return {
                'breached': False,
                'count': 0,
                'message': "Password not found in known breaches"
            }
            
        except requests.exceptions.SSLError as e:
            return {
                'breached': None,
                'count': 0,
                'message': f"SSL Error: {str(e)}. Try updating certificates: pip install --upgrade certifi"
            }
        except requests.exceptions.ConnectionError as e:
            return {
                'breached': None,
                'count': 0,
                'message': f"Connection Error: {str(e)}. Check internet connection."
            }
        except requests.exceptions.RequestException as e:
            return {
                'breached': None,
                'count': 0,
                'message': f"Error checking breaches: {str(e)}"
            }
        except ValueError as e:
            return {
                'breached': None,
                'count': 0,
                'message': f"Error parsing response: {str(e)}"
            }

class SecureStorage:
    """Handles secure password storage with encryption."""
    
    def __init__(self, master_password):
        self.storage_file = "passwords.enc"
        self.key = self._derive_key(master_password)
        self.cipher = Fernet(self.key)
    
    def _derive_key(self, password):
        """Derive encryption key from master password."""
        try:
            # Use a fixed salt for simplicity (in production, store salt separately)
            salt = b'static_salt_for_demo_only_change_this'
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=salt,
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
            return key
        except Exception as e:
            print(f"‚ùå Error deriving encryption key: {e}")
            print("This might indicate an issue with the cryptography library.")
            raise
    
    def save_password(self, service, username, password):
        """Save a password entry securely."""
        try:
            # Load existing data
            data = self.load_all_passwords()
            
            # Add new entry
            data[service] = {
                'username': username,
                'password': password,
                'created': time.time()
            }
            
            # Encrypt and save
            encrypted_data = self.cipher.encrypt(json.dumps(data).encode())
            with open(self.storage_file, 'wb') as f:
                f.write(encrypted_data)
            
            return True
        except Exception as e:
            print(f"Error saving password: {e}")
            return False
    
    def load_all_passwords(self):
        """Load all stored passwords."""
        try:
            if not os.path.exists(self.storage_file):
                return {}
            
            with open(self.storage_file, 'rb') as f:
                encrypted_data = f.read()
            
            if not encrypted_data:  # Handle empty file
                return {}
                
            decrypted_data = self.cipher.decrypt(encrypted_data)
            return json.loads(decrypted_data.decode())
        except Exception as e:
            print(f"‚ö†Ô∏è  Warning: Could not load passwords - {e}")
            print("This might be due to wrong master password or corrupted file.")
            return {}  # Return empty dict if file doesn't exist or can't decrypt
    
    def get_password(self, service):
        """Retrieve password for a specific service."""
        data = self.load_all_passwords()
        return data.get(service)
    
    def list_services(self):
        """List all stored services."""
        data = self.load_all_passwords()
        return list(data.keys())

def main():
    """Main application interface."""
    print("üîê Password Security Analyzer & Manager")
    print("=" * 50)
    
    analyzer = PasswordAnalyzer()
    breach_checker = BreachChecker()
    
    while True:
        print("\nüìã Options:")
        print("1. Analyze password strength")
        print("2. Check password breaches")
        print("3. Store password securely")
        print("4. Retrieve stored password")
        print("5. List stored services")
        print("6. Exit")
        
        choice = input("\nSelect option (1-6): ").strip()
        
        if choice == '1':
            password = getpass.getpass("Enter password to analyze: ")
            result = analyzer.analyze_strength(password)
            
            print(f"\nüìä Password Analysis Results:")
            print(f"Strength: {result['strength']} (Score: {result['score']}/100)")
            print(f"Length: {result['length']} characters")
            
            if result['feedback']:
                print("\nüí° Suggestions for improvement:")
                for suggestion in result['feedback']:
                    print(f"  ‚Ä¢ {suggestion}")
        
        elif choice == '2':
            password = getpass.getpass("Enter password to check for breaches: ")
            print("üîç Checking against breach databases...")
            result = breach_checker.check_password_breach(password)
            
            if result['breached']:
                print(f"‚ö†Ô∏è  {result['message']}")
            elif result['breached'] is False:
                print(f"‚úÖ {result['message']}")
            else:
                print(f"‚ùå {result['message']}")
        
        elif choice == '3':
            master_password = getpass.getpass("Enter master password for storage: ")
            storage = SecureStorage(master_password)
            
            service = input("Service name: ")
            username = input("Username: ")
            password = getpass.getpass("Password to store: ")
            
            if storage.save_password(service, username, password):
                print("‚úÖ Password saved successfully!")
            else:
                print("‚ùå Failed to save password")
        
        elif choice == '4':
            master_password = getpass.getpass("Enter master password: ")
            storage = SecureStorage(master_password)
            
            service = input("Service name: ")
            entry = storage.get_password(service)
            
            if entry:
                print(f"\nüìã Password for {service}:")
                print(f"Username: {entry['username']}")
                print(f"Password: {entry['password']}")
            else:
                print("‚ùå No password found for that service")
        
        elif choice == '5':
            master_password = getpass.getpass("Enter master password: ")
            storage = SecureStorage(master_password)
            
            services = storage.list_services()
            if services:
                print("\nüìã Stored services:")
                for service in services:
                    print(f"  ‚Ä¢ {service}")
            else:
                print("No passwords stored yet")
        
        elif choice == '6':
            print("üëã Goodbye!")
            break
        
        else:
            print("‚ùå Invalid option. Please try again.")

if __name__ == "__main__":
    main()